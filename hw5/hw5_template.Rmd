---
title: "hw5"
author: "Anuj Desai"
date: "Due 11:59pm Wednesday, July 13, 2016"
output: html_document
---

## Packages

The following packages are allowed for this assignment:

* rvest
* xml2
* ggplot2
* lubridate
* stringr
* dplyr
* tidyr
* readr
* scales

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(rvest)
library(ggplot2)
library(dplyr)
library(stringr)
library(lubridate)
library(scales)
```

## Nuclear Reactors

## Introduction
In this homework, you'll be scraping tables off the Wikipedia website.  The idea of doing this is always the same: find XPath expressions that lead to tables of interest, scrape them using `html_nodes()`, remove problem nodes with subsetting, and then converting the tables using `html_table()`.  Your goal is to produce the two graphs at the bottom of these instructions.

The aim of this assignment is to show you how dirty online data sources can be.  As you'll find out, finding and reading in the data will be the least of your worries.  You'll spend a good chunk of time thinking of how to clean the data before you can even think about plotting it! Do not despair---while there may not be enough examples in the world to show you every case you might come up against, the more you practice thinking about these issues on your own, the stronger your __intuition__ will become.

## Restrictions
To ensure that you are actually thinking about wrangling strategies, any manipulation of the data frame must be done with `dplyr` wrangling verbs (with the exception of renaming the columns).

__Bonus__: You may earn 10 bonus points if your code chunks:

* Never exceeds 80 characters in width
* Never calls on more than 3 functions per line
* Doesn't exceed 80 lines total

If you're using RStudio, the numbers on the bottom-left of the code panel show where the cursor is in the document.  Use this to check if you're within the limits.  You'll need to make full use of all the tools we've learned in class so far---from writing functions to using the `lapply` family.

## Starter Code
The starter code below should prime your thinking.  The angle brackets are __not__ literal.  Do not include them when running your code.
```{r, eval = F}

# remember that the dot shows where the pipe is placing the output
# of the function from the last line.  The third pipe leads into the subsetting
# operator.  This is probably where you want to remove problem nodes...
page <- "http://en.wikipedia.org/wiki/List_of_nuclear_reactors"
xpath <- <some_path_here>
table_list <- page %>%
  read_html() %>%
  html_nodes(xpath = xpath) %>%
  .[<some_vector_here>] %>%
  html_table(fill = TRUE)

# The above code returns a list of tables.  Use subsetting to pick out specific tables
table_list[[<some_number_here>]]

# A vector of names you might want in your initial data frame
new_names <- c("name", "reactor", "type", "model", "status", 
               "net", "gross", "const_start", "op_start", "closure")

# An example of slice from the dplyr package.  It's like filter, but for picking
# out specific rows.  You may or may not use this.
df <- data.frame(x = 1:3, y = 4:6)
df %>% slice(c(1,3))
df %>% slice(-3)
```

```{r fig.width = 9.5, fig.asp = 0.5, warning = F}
page <- "http://en.wikipedia.org/wiki/List_of_nuclear_reactors"
xpath <- '//div[@id="mw-content-text"]/table'
reactor_tbl <- page %>% 
  read_html() %>% 
  html_nodes(xpath = xpath) %>% 
  .[c(16, 23)] %>% 
  html_table(fill = TRUE)
# France Data Frame
france <- reactor_tbl[[1]]
names(france) <- c("name", "reactor", "type", "model", "status", 
               "net", "gross", "const_start", "op_start", "closure")
france_df <- france %>% 
  slice(-1) %>%
  mutate(country = "France") %>% 
  mutate(const_start = dmy(const_start))
# Japan Data Frame
japan <- reactor_tbl[[2]]
names(japan) <- names(france)
japan_df <- japan %>% 
  slice(-1) %>% 
  mutate(country = "Japan") %>% 
  mutate(const_start = dmy(const_start))
# Joined Data Frame of Japanese and French reactors
france_and_japan <- full_join(france_df, japan_df) %>%
  select(type, net, const_start, country) %>%
  mutate(net = as.numeric(net)) %>% 
  mutate(type = factor(type)) %>% 
  na.omit()
levels(france_and_japan$type) <- c("", "Boiling Water", 
                                   "Fast Breeder", "Gas Cooled",
                                   "Heavy Water Gas Cooled", 
                                   "Pressurized Water")
# Plot 1: Net Reactor Capacities in France and Japan
ggplot(france_and_japan, aes(x = const_start, y = net, 
                             shape = type, color = country)) +
  geom_point(size = 2, stroke = 0.25) +
  scale_x_date(limits = as.Date(c("1954", "2005"), "%Y")) +
  scale_y_continuous(limits = c(0, 1500), breaks = seq(0, 1500, 500)) +
  labs(x = "Construction Start Date",
       y = "Net Capacity (MW)",
       title = "Net Reactor Capacities\n in France and Japan",
       shape = "Reactor Type",
       color = "Country")
```

```{r fig.width = 9, fig.asp = 0.75}
japan_reactors <- japan_df %>% 
  select(name, reactor, type, const_start, op_start) %>% 
  mutate(op_start = dmy(op_start)) %>% 
  mutate(name_reactor = str_c(name, reactor)) %>% 
  mutate(type = factor(type)) %>%
  mutate(names = str_replace_all(name_reactor, ".*[2-9]$", "")) %>% 
  mutate(names = str_replace_all(names, "[1]", "")) %>% 
  na.omit()
levels(japan_reactors$type) <- c("", "Boiling Water", 
                                   "Fast Breeder", "Gas Cooled",
                                   "Pressurized Water")
# Plot 2: Construction Times for Japanese Nuclear Reactors
ggplot(japan_reactors, aes(x = const_start, y = rev(name_reactor), color = type)) +
  geom_segment(aes(xend = op_start, yend = rev(name_reactor))) +
  scale_x_date(labels = date_format("%Y"),
               breaks = seq(ymd(19600101), ymd(20100101), by="5 years")) +
  scale_y_discrete(labels = rev(japan_reactors$names)) +
  labs(x = "Date",
       y = "Reactor Site",
       title = "Construction Times for\n Japanese Nuclear Reactors",
       color = "Reactor Type")
```

## Hints:
1. The US nuclear reactor table doesn't behave nicely---why? Read through the assumptions of `html_table`.
2. As you try to clean the French nuclear reactor data, one of the dates will not parse---why? You can ignore this particular row.
3. You'll need to fix the column names! No `dplyr` function will handle this correctly since the columns are not unique.  You'll have to rely on the class `names()` function.
4. The size of the points in the France-Japan scatterplot is 2.
5. The geometries in the Japan Construction graph are segments.
6. You'll have to play with the `breaks` and `labels` of both axes.
7. If you use `date_format`, you'll need to load the `ggplot2` library extension `scales`.
8. By default, strings are alphabetized for graphing.  If you turn the data into an ordered factor however...
9. All the reactors are present, but only one instance of the reactor name shows up for each reactor site.  For example `Tsuruga 1` and `Tsuruga 2` both show up under `Tsuruga` with the second one being represented by a tick with no label.
10. Empty strings don't show up...

